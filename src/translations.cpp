/*
Holyrics Finder Plugin
Copyright (C) 2024

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
*/

#include "translations.h"
#include <QMap>

QString Translations::s_currentLanguage = "en";

// UTF-8 encoded strings for Portuguese characters
static QString ptBR_conexao() { 
	static const unsigned char utf8[] = {0x43, 0x6F, 0x6E, 0x65, 0x78, 0xC3, 0xA3, 0x6F, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_endereco() { 
	static const unsigned char utf8[] = {0x45, 0x6E, 0x64, 0x65, 0x72, 0x65, 0xC3, 0xA7, 0x6F, 0x20, 0x49, 0x50, 0x20, 0x64, 0x6F, 0x20, 0x48, 0x6F, 0x6C, 0x79, 0x72, 0x69, 0x63, 0x73, 0x3A, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_testar() { 
	static const unsigned char utf8[] = {0x54, 0x65, 0x73, 0x74, 0x61, 0x72, 0x20, 0x43, 0x6F, 0x6E, 0x65, 0x78, 0xC3, 0xA3, 0x6F, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_testando() { 
	static const unsigned char utf8[] = {0x54, 0x65, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x6F, 0x20, 0x63, 0x6F, 0x6E, 0x65, 0x78, 0xC3, 0xA3, 0x6F, 0x20, 0x63, 0x6F, 0x6D, 0x20, 0x25, 0x31, 0x3A, 0x25, 0x32, 0x2E, 0x2E, 0x2E, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_instancias() { 
	static const unsigned char utf8[] = {0x45, 0x73, 0x63, 0x61, 0x6E, 0x65, 0x61, 0x6E, 0x64, 0x6F, 0x20, 0x61, 0x20, 0x72, 0x65, 0x64, 0x65, 0x20, 0x70, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x73, 0x74, 0xC3, 0xA2, 0x6E, 0x63, 0x69, 0x61, 0x73, 0x20, 0x64, 0x6F, 0x20, 0x48, 0x6F, 0x6C, 0x79, 0x72, 0x69, 0x63, 0x73, 0x2E, 0x2E, 0x2E, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_concluido() { 
	static const unsigned char utf8[] = {0x45, 0x73, 0x63, 0x61, 0x6E, 0x65, 0x61, 0x6D, 0x65, 0x6E, 0x74, 0x6F, 0x20, 0x64, 0x65, 0x20, 0x72, 0x65, 0x64, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x63, 0x6C, 0x75, 0xC3, 0xAD, 0x64, 0x6F, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_bem_sucedida() { 
	static const unsigned char utf8[] = {0xE2, 0x9C, 0x93, 0x20, 0x43, 0x6F, 0x6E, 0x65, 0x78, 0xC3, 0xA3, 0x6F, 0x20, 0x62, 0x65, 0x6D, 0x2D, 0x73, 0x75, 0x63, 0x65, 0x64, 0x69, 0x64, 0x61, 0x20, 0x63, 0x6F, 0x6D, 0x20, 0x25, 0x31, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_precisam() { 
	static const unsigned char utf8[] = {0xE2, 0x9C, 0x93, 0x20, 0x43, 0x6F, 0x6E, 0x65, 0x78, 0xC3, 0xA3, 0x6F, 0x20, 0x62, 0x65, 0x6D, 0x2D, 0x73, 0x75, 0x63, 0x65, 0x64, 0x69, 0x64, 0x61, 0x20, 0x63, 0x6F, 0x6D, 0x20, 0x25, 0x31, 0x3A, 0x25, 0x32, 0x20, 0x2D, 0x20, 0x25, 0x33, 0x20, 0x66, 0x6F, 0x6E, 0x74, 0x65, 0x28, 0x73, 0x29, 0x20, 0x70, 0x72, 0x65, 0x63, 0x69, 0x73, 0x61, 0x6D, 0x20, 0x73, 0x65, 0x72, 0x20, 0x61, 0x74, 0x75, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0x64, 0x61, 0x73, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_ja_estao() { 
	static const unsigned char utf8[] = {0xE2, 0x9C, 0x93, 0x20, 0x43, 0x6F, 0x6E, 0x65, 0x78, 0xC3, 0xA3, 0x6F, 0x20, 0x62, 0x65, 0x6D, 0x2D, 0x73, 0x75, 0x63, 0x65, 0x64, 0x69, 0x64, 0x61, 0x20, 0x63, 0x6F, 0x6D, 0x20, 0x25, 0x31, 0x3A, 0x25, 0x32, 0x20, 0x2D, 0x20, 0x54, 0x6F, 0x64, 0x61, 0x73, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x6E, 0x74, 0x65, 0x73, 0x20, 0x6A, 0xC3, 0xA1, 0x20, 0x65, 0x73, 0x74, 0xC3, 0xA3, 0x6F, 0x20, 0x61, 0x74, 0x75, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0x64, 0x61, 0x73, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_falha() { 
	static const unsigned char utf8[] = {0xE2, 0x9C, 0x97, 0x20, 0x46, 0x61, 0x6C, 0x68, 0x61, 0x20, 0x6E, 0x61, 0x20, 0x63, 0x6F, 0x6E, 0x65, 0x78, 0xC3, 0xA3, 0x6F, 0x20, 0x63, 0x6F, 0x6D, 0x20, 0x25, 0x31, 0x3A, 0x25, 0x32, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_copiado() { 
	static const unsigned char utf8[] = {0xE2, 0x9C, 0x93, 0x20, 0x43, 0x6F, 0x70, 0x69, 0x61, 0x64, 0x6F, 0x20, 0x70, 0x61, 0x72, 0x61, 0x20, 0xC3, 0xA1, 0x72, 0x65, 0x61, 0x20, 0x64, 0x65, 0x20, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x65, 0x72, 0xC3, 0xAA, 0x6E, 0x63, 0x69, 0x61, 0x3A, 0x20, 0x25, 0x31, 0x3A, 0x25, 0x32, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_atualizadas() { 
	static const unsigned char utf8[] = {0xE2, 0x9C, 0x93, 0x20, 0x41, 0x74, 0x75, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0x64, 0x61, 0x73, 0x20, 0x25, 0x31, 0x20, 0x66, 0x6F, 0x6E, 0x74, 0x65, 0x28, 0x73, 0x29, 0x20, 0x70, 0x61, 0x72, 0x61, 0x20, 0x25, 0x32, 0x3A, 0x25, 0x33, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_atualizar_fontes() { 
	static const unsigned char utf8[] = {0x41, 0x74, 0x75, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0x72, 0x20, 0x46, 0x6F, 0x6E, 0x74, 0x65, 0x73, 0x20, 0x53, 0x65, 0x6C, 0x65, 0x63, 0x69, 0x6F, 0x6E, 0x61, 0x64, 0x61, 0x73, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString checkmark() { 
	static const unsigned char utf8[] = {0xE2, 0x9C, 0x93, 0x20, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString xmark() { 
	static const unsigned char utf8[] = {0xE2, 0x9C, 0x97, 0x20, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_paineis() { 
	static const unsigned char utf8[] = {0x50, 0x61, 0x69, 0x6E, 0xC3, 0xA9, 0x69, 0x73, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_selecione_paineis() { 
	static const unsigned char utf8[] = {0x50, 0x61, 0x69, 0x6E, 0xC3, 0xA9, 0x69, 0x73, 0x20, 0x70, 0x65, 0x72, 0x73, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0x64, 0x6F, 0x73, 0x20, 0x64, 0x6F, 0x20, 0x6E, 0x61, 0x76, 0x65, 0x67, 0x61, 0x64, 0x6F, 0x72, 0x20, 0x71, 0x75, 0x65, 0x20, 0x70, 0x72, 0x65, 0x63, 0x69, 0x73, 0x61, 0x6D, 0x20, 0x64, 0x65, 0x20, 0x61, 0x74, 0x75, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0xC3, 0xA7, 0xC3, 0xA3, 0x6F, 0x2E, 0x20, 0x43, 0x6C, 0x69, 0x71, 0x75, 0x65, 0x20, 0x6E, 0x6F, 0x20, 0x62, 0x6F, 0x74, 0xC3, 0xA3, 0x6F, 0x20, 0x70, 0x61, 0x72, 0x61, 0x20, 0x63, 0x6F, 0x70, 0x69, 0x61, 0x72, 0x20, 0x61, 0x20, 0x55, 0x52, 0x4C, 0x20, 0x63, 0x6F, 0x72, 0x72, 0x65, 0x74, 0x61, 0x2E, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_nenhum_painel() { 
	static const unsigned char utf8[] = {0x4E, 0x65, 0x6E, 0x68, 0x75, 0x6D, 0x20, 0x70, 0x61, 0x69, 0x6E, 0x65, 0x6C, 0x20, 0x70, 0x65, 0x72, 0x73, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0x64, 0x6F, 0x20, 0x63, 0x6F, 0x6D, 0x20, 0x49, 0x50, 0x3A, 0x50, 0x6F, 0x72, 0x74, 0x61, 0x20, 0x65, 0x6E, 0x63, 0x6F, 0x6E, 0x74, 0x72, 0x61, 0x64, 0x6F, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_config_nao_encontrado() { 
	static const unsigned char utf8[] = {0x41, 0x72, 0x71, 0x75, 0x69, 0x76, 0x6F, 0x20, 0x64, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0xC3, 0xA7, 0xC3, 0xA3, 0x6F, 0x20, 0x64, 0x6F, 0x20, 0x4F, 0x42, 0x53, 0x20, 0x6E, 0xC3, 0xA3, 0x6F, 0x20, 0x65, 0x6E, 0x63, 0x6F, 0x6E, 0x74, 0x72, 0x61, 0x64, 0x6F, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_url_copiada() { 
	static const unsigned char utf8[] = {0xE2, 0x9C, 0x93, 0x20, 0x55, 0x52, 0x4C, 0x20, 0x63, 0x6F, 0x70, 0x69, 0x61, 0x64, 0x61, 0x20, 0x70, 0x61, 0x72, 0x61, 0x20, 0x27, 0x25, 0x31, 0x27, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QString ptBR_atualizar_lista() { 
	static const unsigned char utf8[] = {0x41, 0x74, 0x75, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0x72, 0x20, 0x4C, 0x69, 0x73, 0x74, 0x61, 0}; 
	return QString::fromUtf8(reinterpret_cast<const char*>(utf8)); 
}

static QMap<QString, QMap<QString, QString>> getTranslations() {
	QMap<QString, QMap<QString, QString>> translations;
	
	// English
	translations["en"] = {
		{"menu.name", "Holyrics Finder"},
		{"window.title", "Holyrics Finder"},
		{"connection.group", "Connection"},
		{"connection.ip_label", "Holyrics IP Address:"},
		{"connection.port_label", "Port:"},
		{"connection.test_button", "Test Connection"},
		{"connection.scan_button", "Scan Network"},
		{"connection.copy_button", "Copy IP:Port"},
		{"status.ready", "Ready"},
		{"status.testing", "Testing connection to %1:%2..."},
		{"status.scanning", "Scanning network for Holyrics instances..."},
		{"status.scanning_progress", "Scanning network... %1/%2"},
		{"status.scan_complete", "Network scan complete"},
		{"status.connection_success", checkmark() + "Connection successful to %1"},
		{"status.connection_success_sources", checkmark() + "Connection successful to %1:%2 - %3 source(s) need updating"},
		{"status.connection_success_uptodate", checkmark() + "Connection successful to %1:%2 - All sources already up to date"},
		{"status.connection_failed", xmark() + "Connection failed to %1"},
		{"status.copied", checkmark() + "Copied to clipboard: %1"},
		{"status.updated_sources", checkmark() + "Updated %1 source(s) to %2:%3"},
		{"status.no_sources_selected", "No sources selected to update"},
		{"sources.group", "Browser Sources"},
		{"sources.tab_title", "Sources"},
		{"sources.label", "Select browser sources to update with the new IP:Port:"},
		{"sources.select_all", "Select All"},
		{"sources.deselect_all", "Deselect All"},
		{"sources.refresh", "Refresh List"},
		{"sources.update_button", "Update Selected Sources"},
		{"docks.tab_title", "Docks"},
		{"docks.label", "Custom browser docks that need updating. Click the button to copy the correct URL so you can manually update it."},
		{"docks.copy_url", "Copy URL"},
		{"docks.refresh", "Refresh List"},
		{"docks.none_found", "No custom browser docks with IP:Port found"},
		{"docks.not_found", "OBS config file not found"},
		{"docks.url_copied", checkmark() + "URL copied for '%1'"},
		{"button.close", "Close"}
	};
	
	// Portuguese (Brazil)
	translations["pt-BR"] = {
		{"menu.name", "Localizador Holyrics"},
		{"window.title", "Localizador Holyrics"},
		{"connection.group", ptBR_conexao()},
		{"connection.ip_label", ptBR_endereco()},
		{"connection.port_label", "Porta:"},
		{"connection.test_button", ptBR_testar()},
		{"connection.scan_button", "Escanear Rede"},
		{"connection.copy_button", "Copiar IP:Porta"},
		{"status.ready", "Pronto"},
		{"status.testing", ptBR_testando()},
		{"status.scanning", ptBR_instancias()},
		{"status.scanning_progress", "Escaneando rede... %1/%2"},
		{"status.scan_complete", ptBR_concluido()},
		{"status.connection_success", ptBR_bem_sucedida()},
		{"status.connection_success_sources", ptBR_precisam()},
		{"status.connection_success_uptodate", ptBR_ja_estao()},
		{"status.connection_failed", ptBR_falha()},
		{"status.copied", ptBR_copiado()},
		{"status.updated_sources", ptBR_atualizadas()},
		{"status.no_sources_selected", "Nenhuma fonte selecionada para atualizar"},
		{"sources.group", "Fontes do Navegador"},
		{"sources.tab_title", "Fontes"},
		{"sources.label", "Selecione as fontes do navegador para atualizar com o novo IP:Porta:"},
		{"sources.select_all", "Selecionar Todas"},
		{"sources.deselect_all", "Desmarcar Todas"},
		{"sources.refresh", ptBR_atualizar_lista()},
		{"sources.update_button", ptBR_atualizar_fontes()},
		{"docks.tab_title", ptBR_paineis()},
		{"docks.label", ptBR_selecione_paineis()},
		{"docks.copy_url", "Copiar URL"},
		{"docks.refresh", ptBR_atualizar_lista()},
		{"docks.none_found", ptBR_nenhum_painel()},
		{"docks.not_found", ptBR_config_nao_encontrado()},
		{"docks.url_copied", ptBR_url_copiada()},
		{"button.close", "Fechar"}
	};
	
	return translations;
}

QString Translations::get(const QString &key)
{
	static QMap<QString, QMap<QString, QString>> translations = getTranslations();
	
	if (translations.contains(s_currentLanguage)) {
		const QMap<QString, QString> &langMap = translations[s_currentLanguage];
		if (langMap.contains(key)) {
			return langMap[key];
		}
	}
	
	// Fallback to English
	if (s_currentLanguage != "en" && translations.contains("en")) {
		const QMap<QString, QString> &englishMap = translations["en"];
		if (englishMap.contains(key)) {
			return englishMap[key];
		}
	}
	
	return key;
}

void Translations::setLanguage(const QString &lang)
{
	s_currentLanguage = lang;
}

QString Translations::getCurrentLanguage()
{
	return s_currentLanguage;
}
